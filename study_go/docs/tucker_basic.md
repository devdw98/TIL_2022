## 4 변수
> 값을 저장하는 메모리 공간을 가리키는 이름

### 변수 선언 방법
- var [이름] [타입] = [초기값]
    ```go
    // year 라고 지칭하는 메모리 시작 주소에 int 타입 크기만큼 공간을 할당하여 2017 값을 복사
    var year int = 2022
    ```
- var [이름] [타입]
    ```go
    // 초기값 생략 -> 타입의 기본값으로 대체
    var name string
    ```
- var [이름] = [초기값]
    ```go
    // 타입 생략 -> 타입은 초기값의 타입
    var language = "kr"
    ```
- [이름] := [초기값]
    ```go
    // 선언 대입문 := 사용하여 var 키워드 생략
    month := 11
    ```
### 변수 범위
- 전역 변수 (global variable)
    - 중괄호 내에 속해있지 않은 변수
- 지역 변수
    - 중괄호 내에 속한 변수

## 표준 입출력 fmt

### 출력
- Print()
- Println()
- Printf()

### 입력
- Scan()
- Scanf()
- Scanln()

## 연산
- 시프트 연산자를 제외한 모든 연산자의 각 항의 타입은 같아야함

### 비트 연산자 (A [ ] B)
- & (AND) : A, B 모두 1인 비트만 1
- | (OR) : A, B 둘 중 하나의 비트가 1이면 1
- ^ (XOR) : A B 가 다르면 1 / 단독으로 쓰면 비트 반전
- ^& (비트 클리어) : 특정 비트를 0으로 바꾸는 연산자, (우변값의 비트 클리어)

# 7 함수

### 함수 선언 방법
- func [함수명] ([매개변수]) [반환타입] {[코드 블록]}
    ```go
    func Add(int a, int b) int {
        return a + b
    }
    ```
    - 함수명의 첫글자가 대문자면 패키지 외부로 공개되는 함수
    - 함수가 호출될 때 입력한 인수(매개변수 자리에 온 값)는 **복사** 됨

### 멀티 반환 함수
- func [함수명] ([매개변수]) ([반환타입], ...) {[코드 블록]}
- 값을 여러 개 반환할 수 있음
    ```go
    func Divide(a, b int) (int, bool) {
        if b == 0 {
            return 0, false
        }
        return a / b, true
    }
    result1, ok1 := Divide(9, 3) // result1 : 3, ok1: true
    result2, ok2 := Divide(9, 0) // result2 : 0, ok2: false
    ```

# 8 상수
### 상수 선언 방식
- const [상수명] [타입] = [값]
    - 타입이 정해진 상수
- const [상수명] = [값]
    - 타입이 정해지지 않은 상수
    - 상수를 변수에 대입할 때 타입이 정해짐

### iota
- 1씩 증가하도록 정의할 때 사용
    ```go
    const (
        ZERO int = iota // 0
        ONE // 1
        TWO // 2
    )
    ```
### 리터럴
- 고정된 값, 값 자체
- 컴파일 타임에 상수값이 리터럴로 변환됨
- 동적 할당 메모리 영역을 사용하지 않음


# 9 if
```go
if [조건문1] {

} else if [조건문2] {

} else {

}
```

# 10 switch
```go
switch [비교값] {
case [값1]:
    [비교값 == 값1 일 때 실행될 로직]
case [값2]:
    [비교값 == 값2 일 때 실행될 로직]
default:
    [조건에 만족하는 값이 없을 때 실행될 로직]
}
```
### 한 번에 여러 값 비교
    ```go
    switch [비교값] {
    case [값1], [값2]:
        [비교값 == 값1 or 비교값 == 값2 일 때 실행될 로직]
    case [값3]:
        [비교값 == 값3 일 때 실행될 로직]
    default:
        [조건에 만족하는 값이 없을 때 실행될 로직]
}
    ```
### [비교값] 자리에 올 수 있는 구문
- 초기문
    - age := getMyAge(); age

### break
- break 문을 사용하지 않아도 case 실행 후 자동으로 switch 문 빠져나감

### fallthrough
- 조건에 맞는 case 문 실행 후 다음 case 문 까지 실행시키고 싶을 때 사용

# 11 for
```go
for [초기문]; [조건문]; [후처리] {
    [반복될 떄 동안 실행될 로직]
}
```
### 형태
- 초기문 생략
    ```go
    for ; [조건문]; [후처리] {

    }
    ```
- 후처리 생략
    ```go
    for [초기문]; [조건문]; {

    }
    ```
- 조건문만 있는 경우
    ```go
    for ; [조건문]; {

    }
    // or
    for [조건문] {

    }
    ```

- 무한루프
    ```go
    for true {

    }
    // or
    for {

    }
    ```

### 레이블
- for 문 정의할 때 레이블을 정의하고, 반복문을 탈출하고 싶을 때 break [레이블] 로 탈출한다.
    ```go
    OuterFor:
        for a := 1; a <= 9; a++ {
            for b := 1; b <= 9; b++ {
                if a * b == 45 {
                    break OuterFor
                }
            }
        }
    ```

# 12 배열
- 연속된 메모리에 할당되어 있다
- 인덱스와 타입 크기를 사용해 메모리 주소를 찾는다

# 13 구조체
- 다른 타입의 값들을 변수 하나로 묶어주는 기능
- 새로운 사용자 정의 타입
- 응집도를 증가시키는 역할

### 선언 방식
- 타입명의 첫번째 글자가 대문자면 패키지 외부로 공개되는 타입
- 초깃값을 생략하면 모든 필드가 기본값으로 초기화됨
```go
type [타입명] struct {
    [필드명] [타입]
    ...
    [필드명] [타입]
}
```

# 14 포인터
- 메모리 주소를 값으로 갖는 타입
```go
a := 10
var p1 *int
p1 = &a     // a의 메모리 주소를 포인터 변수 p1에 대입
*p1 = 20    // a의 주소 내 값 10 -> 20 으로 변경
```

### 인스턴스
- 메모리에 할당된 데이터의 실체
```go
// 하나의 인스턴스를 세 포인터 변수가 가리킴
var p1 *Data = &Data{}
var p2 *Data = p1
var p3 *Data = p1

// 하나의 인스턴스를 각 변수에 복사함 -> 인스턴스 3개
var data1 Data
var data2 Data = data1
var data3 Data = data1
```
- 초기화 방법
    ```go
    p1 := &Data{}       // & 사용
    var p2 = new(Data)  // new() 사용
    ```
    - &
        - 내부 필드 값을 초기화할 수 있음
    - new()
        - 내부 필드 값을 초기화할 수 없음
### 가비지 컬렉터
- 일정 간격 메모리에서 쓸모 없어진 데이터를 지움

### 스택 메모리, 힙 메모리
- 탈출 검사 (escape analysus)로 어느 메모리에 할당할 지 결정함
    - 함수 외부로 공개되는지 여부에 따라 메모리 영역 정함
- 스택 메모리 영역
    - 함수 내부에서만 사용 가능한 영역
- 힙 메모리 영역
    - 함수 외부로 공개되는 메모리 공간은 이곳에 할당

# 16 문자열 (string)
- 문자 집합
- 백 쿼트(`) 로 문자열을 감싸면 특수 문자가 일반 문자처럼 처리됨
- 문자 하나 표현 == rune (= int32) type
- 문자열은 불변이라 일부만 바꿀 수 없음

### 문자열 글자 수 알아내기
- string -> []rune -> len
    ```go
    str := "hello 월드"
    runes := []rune(str)

    fmt.Printf("len(str) : %d\n", len(str)) // 문자열의 바이트 길이인 12
    fmt.Printf("len(runes) = %d\n", len(runes)) // 문자 개수인 8
    ```

### 문자열 순회하기
- string -> []rune 변환 후 순회
- range 사용
    ```go
    str := "hello 월드"
    for _, v := range str {
        fmt.Println(v)
    }
    ```

# 16 패키지
- 코드를 묶는 가장 큰 단위
- main 패키지 : 프로그램 시작점을 포함한 패키지
- 패키지를 import 로 포함시키면 **go build** 할 때 해당하는 패키지를 포함한 다음 실행파일을 생성함

### go module
- go 패키지들을 모아놓은 프로젝트 단위
- go 코드는 go 모듈 아래에 있어야 한다 (1.16 이후로)
- 빌드하려면 무조건 go 모듈 루트 폴더에 go.mod 파일이 있어야 한다
- go.mod
    - 모듈 이름
    - go 버전
    - 필요한 외부 패키지
- go.sum
    - 외부 패키지 버전 정보
```cmd
go mod init [패키지명]  // go 모듈 만들기
go mod tidy           // go 모듈에 필요한 패키지 다운로드 후 go.mod, go.sum 에 기록
```
### 패키지 외부 공개
- 대문자로 시작하는 전역 상수, 함수는 패키지 외부로 공개됨
- 소문자로 시작하면 외부로 공개되지 않음
